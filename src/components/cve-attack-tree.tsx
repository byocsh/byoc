"use client";

import { useEffect, useRef, useState } from "react";
import type p5Type from "p5";

interface CVEItem {
  id: string;
  description: string;
  severity: string;
  score: number | null;
  publishedDate: string;
  lastModifiedDate: string;
  references: string[];
  fixedVersions: string[];
  affectedPackages: string[];
}

interface CVENode {
  id: string;
  x: number;
  y: number;
  vx: number;
  vy: number;
  radius: number;
  severity: string;
  score: number;
  description: string;
  packages: string[];
  type: string; // RCE, XSS, SQLi, etc.
  isHovered: boolean;
  isSelected: boolean;
}

interface Connection {
  from: string;
  to: string;
  strength: number; // shared packages count
  isHighlighted: boolean;
}

// Detect CVE type from description
function detectCVEType(description: string): string {
  const desc = description.toLowerCase();
  if (desc.includes("remote code execution") || desc.includes("rce")) return "RCE";
  if (desc.includes("cross-site scripting") || desc.includes("xss")) return "XSS";
  if (desc.includes("sql injection") || desc.includes("sqli")) return "SQLi";
  if (desc.includes("denial of service") || desc.includes("dos")) return "DoS";
  if (desc.includes("buffer overflow")) return "Buffer";
  if (desc.includes("authentication") || desc.includes("auth bypass")) return "Auth";
  if (desc.includes("information disclosure") || desc.includes("info leak")) return "InfoLeak";
  if (desc.includes("privilege escalation")) return "PrivEsc";
  if (desc.includes("path traversal") || desc.includes("directory traversal")) return "PathTrav";
  if (desc.includes("csrf") || desc.includes("cross-site request")) return "CSRF";
  return "Other";
}

// Get color based on CVE type
function getTypeColor(type: string): { r: number; g: number; b: number } {
  switch (type) {
    case "RCE": return { r: 220, g: 38, b: 38 }; // Red
    case "XSS": return { r: 249, g: 115, b: 22 }; // Orange
    case "SQLi": return { r: 234, g: 179, b: 8 }; // Yellow
    case "DoS": return { r: 168, g: 85, b: 247 }; // Purple
    case "Buffer": return { r: 236, g: 72, b: 153 }; // Pink
    case "Auth": return { r: 59, g: 130, b: 246 }; // Blue
    case "InfoLeak": return { r: 20, g: 184, b: 166 }; // Teal
    case "PrivEsc": return { r: 239, g: 68, b: 68 }; // Red-500
    case "PathTrav": return { r: 132, g: 204, b: 22 }; // Lime
    case "CSRF": return { r: 251, g: 146, b: 60 }; // Orange-400
    default: return { r: 156, g: 163, b: 175 }; // Gray
  }
}

interface CVEAttackTreeProps {
  cves: CVEItem[];
}

export function CVEAttackTree({ cves }: CVEAttackTreeProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const p5InstanceRef = useRef<p5Type | null>(null);
  const [selectedCVE, setSelectedCVE] = useState<CVENode | null>(null);

  useEffect(() => {
    if (!containerRef.current || cves.length === 0) return;

    // Clean up any existing p5 instance first
    if (p5InstanceRef.current) {
      p5InstanceRef.current.remove();
      p5InstanceRef.current = null;
    }
    
    // Also clear any existing canvases in the container
    while (containerRef.current.firstChild) {
      containerRef.current.removeChild(containerRef.current.firstChild);
    }

    import("p5").then((p5Module) => {
      const p5 = p5Module.default;

      const sketch = (p: p5Type) => {
        let nodes: CVENode[] = [];
        let connections: Connection[] = [];
        let isDark = false;
        let hoveredNode: CVENode | null = null;
        let draggedNode: CVENode | null = null;
        let centerX: number, centerY: number;

        const createNodes = () => {
          nodes = cves.map((cve, i) => {
            const angle = (i / cves.length) * p.TAU;
            const radius = Math.min(p.width, p.height) * 0.3;
            return {
              id: cve.id,
              x: p.width / 2 + Math.cos(angle) * radius + p.random(-50, 50),
              y: p.height / 2 + Math.sin(angle) * radius + p.random(-50, 50),
              vx: 0,
              vy: 0,
              radius: mapSeverityToSize(cve.score),
              severity: cve.severity,
              score: cve.score || 0,
              description: cve.description,
              packages: cve.affectedPackages,
              type: detectCVEType(cve.description),
              isHovered: false,
              isSelected: false,
            };
          });

          // Create connections based on shared packages
          connections = [];
          for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
              const sharedPackages = nodes[i].packages.filter(pkg => 
                nodes[j].packages.some(p2 => p2.toLowerCase().includes(pkg.toLowerCase()) || pkg.toLowerCase().includes(p2.toLowerCase()))
              );
              if (sharedPackages.length > 0) {
                connections.push({
                  from: nodes[i].id,
                  to: nodes[j].id,
                  strength: sharedPackages.length,
                  isHighlighted: false,
                });
              }
            }
          }

          // If no connections from packages, connect by severity
          if (connections.length === 0) {
            for (let i = 0; i < nodes.length; i++) {
              for (let j = i + 1; j < nodes.length; j++) {
                if (nodes[i].severity === nodes[j].severity) {
                  connections.push({
                    from: nodes[i].id,
                    to: nodes[j].id,
                    strength: 1,
                    isHighlighted: false,
                  });
                }
              }
            }
          }

          // Connect by type if still no connections
          if (connections.length === 0) {
            for (let i = 0; i < nodes.length; i++) {
              for (let j = i + 1; j < nodes.length; j++) {
                if (nodes[i].type === nodes[j].type) {
                  connections.push({
                    from: nodes[i].id,
                    to: nodes[j].id,
                    strength: 1,
                    isHighlighted: false,
                  });
                }
              }
            }
          }
        };

        const mapSeverityToSize = (score: number | null): number => {
          if (score === null) return 15;
          if (score >= 9) return 35;
          if (score >= 7) return 28;
          if (score >= 4) return 22;
          return 15;
        };

        p.setup = () => {
          const canvas = p.createCanvas(
            containerRef.current!.offsetWidth,
            containerRef.current!.offsetHeight
          );
          canvas.style("display", "block");
          canvas.style("position", "absolute");
          canvas.style("top", "0");
          canvas.style("left", "0");
          isDark = document.documentElement.classList.contains("dark");
          centerX = p.width / 2;
          centerY = p.height / 2;
          createNodes();
        };

        p.draw = () => {
          isDark = document.documentElement.classList.contains("dark");
          p.background(isDark ? 0 : 255);

          // Apply forces
          applyForces();

          // Update positions
          for (const node of nodes) {
            if (node !== draggedNode) {
              node.x += node.vx;
              node.y += node.vy;
              node.vx *= 0.95; // Damping
              node.vy *= 0.95;

              // Keep in bounds
              node.x = p.constrain(node.x, node.radius, p.width - node.radius);
              node.y = p.constrain(node.y, node.radius, p.height - node.radius);
            }
          }

          // Draw connections
          for (const conn of connections) {
            const fromNode = nodes.find(n => n.id === conn.from);
            const toNode = nodes.find(n => n.id === conn.to);
            if (fromNode && toNode) {
              const alpha = conn.isHighlighted ? 200 : 50;
              const weight = conn.isHighlighted ? 3 : 1;
              p.stroke(isDark ? 255 : 0, alpha);
              p.strokeWeight(weight);
              
              if (conn.isHighlighted) {
                // Animated dashed line for highlighted connections
                drawAnimatedLine(fromNode.x, fromNode.y, toNode.x, toNode.y);
              } else {
                p.line(fromNode.x, fromNode.y, toNode.x, toNode.y);
              }
            }
          }

          // Check hover
          hoveredNode = null;
          for (const node of nodes) {
            const d = p.dist(p.mouseX, p.mouseY, node.x, node.y);
            if (d < node.radius) {
              hoveredNode = node;
              node.isHovered = true;
            } else {
              node.isHovered = false;
            }
          }

          // Highlight connections for hovered node
          for (const conn of connections) {
            conn.isHighlighted = hoveredNode !== null && 
              (conn.from === hoveredNode.id || conn.to === hoveredNode.id);
          }

          // Draw nodes
          for (const node of nodes) {
            drawNode(node);
          }

          // Draw tooltip for hovered node
          if (hoveredNode) {
            drawTooltip(hoveredNode);
          }

          // Draw legend
          drawLegend();
        };

        const applyForces = () => {
          // Repulsion between nodes
          for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
              const dx = nodes[j].x - nodes[i].x;
              const dy = nodes[j].y - nodes[i].y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const minDist = nodes[i].radius + nodes[j].radius + 30;

              if (dist < minDist && dist > 0) {
                const force = (minDist - dist) / dist * 0.5;
                const fx = dx * force;
                const fy = dy * force;
                nodes[i].vx -= fx;
                nodes[i].vy -= fy;
                nodes[j].vx += fx;
                nodes[j].vy += fy;
              }
            }
          }

          // Attraction along connections
          for (const conn of connections) {
            const fromNode = nodes.find(n => n.id === conn.from);
            const toNode = nodes.find(n => n.id === conn.to);
            if (fromNode && toNode) {
              const dx = toNode.x - fromNode.x;
              const dy = toNode.y - fromNode.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const targetDist = 150;

              if (dist > targetDist) {
                const force = (dist - targetDist) / dist * 0.01 * conn.strength;
                fromNode.vx += dx * force;
                fromNode.vy += dy * force;
                toNode.vx -= dx * force;
                toNode.vy -= dy * force;
              }
            }
          }

          // Center gravity
          for (const node of nodes) {
            const dx = centerX - node.x;
            const dy = centerY - node.y;
            node.vx += dx * 0.0005;
            node.vy += dy * 0.0005;
          }
        };

        const drawAnimatedLine = (x1: number, y1: number, x2: number, y2: number) => {
          const segments = 20;
          const dashLength = p.dist(x1, y1, x2, y2) / segments;
          const offset = (p.frameCount * 2) % (dashLength * 2);

          for (let i = 0; i < segments; i++) {
            const t1 = (i * dashLength * 2 + offset) / p.dist(x1, y1, x2, y2);
            const t2 = ((i * dashLength * 2 + dashLength) + offset) / p.dist(x1, y1, x2, y2);
            
            if (t1 < 1 && t2 > 0) {
              const startT = Math.max(0, t1);
              const endT = Math.min(1, t2);
              p.line(
                p.lerp(x1, x2, startT),
                p.lerp(y1, y2, startT),
                p.lerp(x1, x2, endT),
                p.lerp(y1, y2, endT)
              );
            }
          }
        };

        const drawNode = (node: CVENode) => {
          const color = getTypeColor(node.type);
          const baseRadius = node.radius;
          const displayRadius = node.isHovered ? baseRadius * 1.2 : baseRadius;

          // Glow effect for hovered/selected
          if (node.isHovered || node.isSelected) {
            p.noStroke();
            for (let i = 3; i > 0; i--) {
              p.fill(color.r, color.g, color.b, 30);
              p.circle(node.x, node.y, displayRadius * 2 + i * 10);
            }
          }

          // Main circle
          p.fill(color.r, color.g, color.b, node.isHovered ? 255 : 200);
          p.stroke(isDark ? 255 : 0, 100);
          p.strokeWeight(node.isHovered ? 2 : 1);
          p.circle(node.x, node.y, displayRadius * 2);

          // Severity ring
          const severityAlpha = node.isHovered ? 255 : 150;
          p.noFill();
          p.strokeWeight(3);
          if (node.severity === "CRITICAL") {
            p.stroke(220, 38, 38, severityAlpha);
          } else if (node.severity === "HIGH") {
            p.stroke(249, 115, 22, severityAlpha);
          } else if (node.severity === "MEDIUM") {
            p.stroke(234, 179, 8, severityAlpha);
          } else {
            p.stroke(34, 197, 94, severityAlpha);
          }
          p.circle(node.x, node.y, displayRadius * 2 + 6);

          // Type label
          p.fill(isDark ? 255 : 0);
          p.noStroke();
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(node.isHovered ? 11 : 9);
          p.textStyle(p.BOLD);
          p.text(node.type, node.x, node.y);

          // Score badge
          if (node.score > 0) {
            p.fill(isDark ? 30 : 240);
            p.circle(node.x + displayRadius, node.y - displayRadius, 20);
            p.fill(isDark ? 255 : 0);
            p.textSize(8);
            p.text(node.score.toFixed(1), node.x + displayRadius, node.y - displayRadius);
          }
        };

        const drawTooltip = (node: CVENode) => {
          const padding = 12;
          const maxWidth = 280;
          
          p.textSize(12);
          p.textAlign(p.LEFT, p.TOP);
          
          const titleHeight = 20;
          const descLines = wrapText(node.description, maxWidth - padding * 2, 11);
          const tooltipHeight = titleHeight + descLines.length * 14 + padding * 2 + 30;
          
          let tooltipX = node.x + node.radius + 15;
          let tooltipY = node.y - tooltipHeight / 2;
          
          // Keep tooltip in bounds
          if (tooltipX + maxWidth > p.width) {
            tooltipX = node.x - node.radius - maxWidth - 15;
          }
          if (tooltipY < 10) tooltipY = 10;
          if (tooltipY + tooltipHeight > p.height - 10) {
            tooltipY = p.height - tooltipHeight - 10;
          }

          // Background
          p.fill(isDark ? 30 : 250, 240);
          p.stroke(isDark ? 100 : 200);
          p.strokeWeight(1);
          p.rect(tooltipX, tooltipY, maxWidth, tooltipHeight, 8);

          // Title (CVE ID)
          p.fill(isDark ? 255 : 0);
          p.textStyle(p.BOLD);
          p.textSize(13);
          p.noStroke();
          p.text(node.id, tooltipX + padding, tooltipY + padding);

          // Severity badge
          const color = getTypeColor(node.type);
          p.fill(color.r, color.g, color.b);
          p.textSize(10);
          p.text(node.type, tooltipX + padding + 150, tooltipY + padding + 2);

          // Description
          p.fill(isDark ? 200 : 60);
          p.textStyle(p.NORMAL);
          p.textSize(11);
          for (let i = 0; i < Math.min(descLines.length, 4); i++) {
            p.text(descLines[i], tooltipX + padding, tooltipY + titleHeight + padding + i * 14);
          }
          if (descLines.length > 4) {
            p.text("...", tooltipX + padding, tooltipY + titleHeight + padding + 4 * 14);
          }

          // Packages
          if (node.packages.length > 0) {
            p.fill(isDark ? 150 : 100);
            p.textSize(10);
            p.text(`Packages: ${node.packages.slice(0, 2).join(", ")}${node.packages.length > 2 ? "..." : ""}`, 
              tooltipX + padding, tooltipY + tooltipHeight - padding - 10);
          }
        };

        const wrapText = (text: string, maxWidth: number, fontSize: number): string[] => {
          const words = text.split(" ");
          const lines: string[] = [];
          let currentLine = "";
          
          p.textSize(fontSize);
          for (const word of words) {
            const testLine = currentLine ? `${currentLine} ${word}` : word;
            if (p.textWidth(testLine) > maxWidth) {
              if (currentLine) lines.push(currentLine);
              currentLine = word;
            } else {
              currentLine = testLine;
            }
          }
          if (currentLine) lines.push(currentLine);
          return lines;
        };

        const drawLegend = () => {
          const legendX = 15;
          const legendY = 15;
          const types = ["RCE", "XSS", "SQLi", "DoS", "Auth", "Other"];
          
          p.fill(isDark ? 30 : 245, 220);
          p.stroke(isDark ? 80 : 200);
          p.strokeWeight(1);
          p.rect(legendX, legendY, 90, types.length * 20 + 30, 6);

          p.fill(isDark ? 255 : 0);
          p.noStroke();
          p.textSize(10);
          p.textStyle(p.BOLD);
          p.textAlign(p.LEFT, p.TOP);
          p.text("CVE Types", legendX + 10, legendY + 8);

          p.textStyle(p.NORMAL);
          p.textSize(9);
          for (let i = 0; i < types.length; i++) {
            const color = getTypeColor(types[i]);
            p.fill(color.r, color.g, color.b);
            p.circle(legendX + 18, legendY + 32 + i * 20, 10);
            p.fill(isDark ? 200 : 60);
            p.text(types[i], legendX + 30, legendY + 28 + i * 20);
          }
        };

        p.mousePressed = () => {
          for (const node of nodes) {
            const d = p.dist(p.mouseX, p.mouseY, node.x, node.y);
            if (d < node.radius) {
              draggedNode = node;
              // Dispatch event for React to handle
              window.dispatchEvent(new CustomEvent("cveNodeClick", { detail: node }));
              break;
            }
          }
        };

        p.mouseReleased = () => {
          draggedNode = null;
        };

        p.mouseDragged = () => {
          if (draggedNode) {
            draggedNode.x = p.mouseX;
            draggedNode.y = p.mouseY;
            draggedNode.vx = 0;
            draggedNode.vy = 0;
          }
        };

        p.windowResized = () => {
          if (containerRef.current) {
            p.resizeCanvas(
              containerRef.current.offsetWidth,
              containerRef.current.offsetHeight
            );
            centerX = p.width / 2;
            centerY = p.height / 2;
          }
        };
      };

      p5InstanceRef.current = new p5(sketch, containerRef.current!);
    });

    return () => {
      p5InstanceRef.current?.remove();
    };
  }, [cves]);

  // Listen for node clicks
  useEffect(() => {
    const handleNodeClick = (e: Event) => {
      const customEvent = e as CustomEvent<CVENode>;
      setSelectedCVE(customEvent.detail);
    };
    window.addEventListener("cveNodeClick", handleNodeClick);
    return () => window.removeEventListener("cveNodeClick", handleNodeClick);
  }, []);

  if (cves.length === 0) {
    return null;
  }

  return (
    <div className="border border-gray-200 dark:border-gray-800 p-4 mt-4">
      <div className="flex items-center justify-between mb-3">
        <h3 className="text-sm font-semibold">CVE Attack Tree</h3>
      </div>
      <div 
        ref={containerRef} 
        className="bg-white dark:bg-black rounded overflow-hidden h-[400px] relative"
      />
      {selectedCVE && (
        <div className="mt-3 p-3 bg-gray-50 dark:bg-gray-900 rounded text-sm">
          <div className="flex items-center justify-between mb-2">
            <a 
              href={`https://nvd.nist.gov/vuln/detail/${selectedCVE.id}`}
              target="_blank"
              rel="noopener noreferrer"
              className="font-mono font-medium hover:underline"
            >
              {selectedCVE.id}
            </a>
            <span className={`text-xs px-2 py-0.5 rounded ${
              selectedCVE.severity === "CRITICAL" ? "bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-300" :
              selectedCVE.severity === "HIGH" ? "bg-orange-100 dark:bg-orange-900 text-orange-700 dark:text-orange-300" :
              selectedCVE.severity === "MEDIUM" ? "bg-yellow-100 dark:bg-yellow-900 text-yellow-700 dark:text-yellow-300" :
              "bg-green-100 dark:bg-green-900 text-green-700 dark:text-green-300"
            }`}>
              {selectedCVE.severity} ({selectedCVE.score})
            </span>
          </div>
          <p className="text-gray-600 dark:text-gray-400 text-xs">
            {selectedCVE.description.slice(0, 200)}...
          </p>
          <button 
            onClick={() => setSelectedCVE(null)}
            className="mt-2 text-xs text-gray-500 hover:text-gray-700 dark:hover:text-gray-300"
          >
            Close
          </button>
        </div>
      )}
    </div>
  );
}
